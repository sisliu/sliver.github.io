---
layout:     post
title:      "js变量，作用域"
subtitle:   " \"js高级程序设计\""
date:       2020-04-05 17:34:24
author:     "ZH"
header-img: "img/post-sample-image.jpg"
catalog: true
tags:
    - JS
---

### 基本类型和引用类型的值
ECMAScript变量包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。    
基本数据类型是按值访问的，因此可以操作保存在变量中的实际的值。    
引用类型的值是保存在内存中的对象。与其它语言不同的是，js不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

#### 动态属性
对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。

```
var person = new Object()
person.name = "NIcholas"
alert(person.name) // "NIcholas"
```
对于基本类型的值我们不能添加属性，尽管不会导致任何错误。

#### 复制变量值
对于复制基本类型值和引用类型值也存在不同。复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。来看个例子。

```
var num1 = 2
var num2 = num1
```
这两个变量可以参与任何操作而不会相互影响。    
而对于引用类型进行复制时，同时也会将存储在边路对象中的值复制一份放到新变量分配的空间中。但是不同的时，这个值得副本实际上是个指针，也就是说，这两个变量实际上引用同一个对象。如果这时候我们改变一个变量，其余变量也会随之改变。

```
var obj1 = new Object()
var obj2 = obj1
obj1.name = "Nicholas"
alert(obj2.name)
```
如果这时候改变obj1.name属性值。obj2.name也会随之改变
#### 传递参数
在所有函数的参数都是按值传递的    
在向函数参数传递基本类型值时，被传递的值会被复制给一个局部变量。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部。    
```
function addTen(num){
    num += 10
    return num
}
var count = 20
var result = addTen(count)
alert(count) // 20
alert(result)//30
```
而对于引用类型来说，就不是这么理解了。    
```
function setName(obj){
    obj.name = "Nicholas"
}
var person = new Object()
setName(person)
alert(person.name) // "Nicholas"
```
在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象。我们再来看个例子    
```
function setName(obj){
    obj.name = "Nicholas"
    obj = new Object()
    obj.name = ""zh
}
var person = new Object()
setName(person)
alert(person.name)// Nicholas
```
结果依然还是"Nicholas"，如果person是按引用传递的话，那么值应该是zh。实际上即使在函数内部修改了参数的值，原始的引用依然保持不变。当在函数内部重写obj时。这个变量的引用就是一个局部对象了。而这个局部对象会在函数执行完毕后立即销毁。
#### 检测类型
虽然在检测基本数据类型时，typeof是非常得力的助手。但是在检测引用类型值时，用处不大。通常我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此es提供了instanceof操作符。参数：object（要检测的对象.）constructor（某个构造函数）    
值得注意的是，对正则表达式，由于规范的原因，typeof会返回function。原因是ECMA-262规定任何在内部实现[[call]]方法的对象都应该在应用typeof操作符返回function。由于safari5及之前的版本和chrome7及之前的版本正则都实现了这个方法，所以会返回function。在ie和Firefox中，会返回object
